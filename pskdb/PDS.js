
var cutil   = require("../signsensus/lib/consUtil");
var ssutil  = require("pskcrypto");


function DataShell(parentLayer){
    var cset            = {};  // containes all keys in parent storage, contains only keys touched in handlers
    var writeSet        = !parentLayer ? cset : {};   //contains only keys modified in handlers

    var readSetVersions  = {}; //meaningful only in handlers
    var writeSetVersions = {}; //will store all versions generated by writeKey

    var vsd             = "empty"; //only for parent storage
    var previousVSD     = null; //TODO: this should disappear as itsrole will be taken by the block's hash

    var myCurrentPulse    = 0; //TODO: this should disappear as it is not necessary to keep it in datashell !
    var self = this;


    function hasLocalKey(name){
        return cset.hasOwnProperty(name);
    }

    this.hasKey = function(name){
        return parentLayer ? parentLayer.hasKey(name) : hasLocalKey(name);
    }

    this.readKey = function readKey(name){
        var value = undefined;
        if(hasLocalKey(name)){
            value = cset[name];
        }else{
            if(self.hasKey(name)){
                value = parentLayer.readKey(name);
                cset[name] = value;
                readSetVersions[name] = parentLayer.getVersion(name);
            }else{
                cset[name] = undefined;
                readSetVersions[name] = 0;
            }
            writeSetVersions[name] = readSetVersions[name];
        }
        return value;
    }

    this.getVersion = function(name, realVersion){
        var version = 0;
        if(hasLocalKey(name)){
            version = readSetVersions[name];
        }else{
            if(this.hasKey(name)){
                cset[name] = parentLayer.readKey();
                version = readSetVersions[name] = parentLayer.getVersion(name);
            }else{
                cset[name] = undefined;
                readSetVersions[name] = version;
            }
        }
        return version;
    }

    this.writeKey = function modifyKey(name, value){
        var k = this.readKey(name);

        cset [name] = value;
        writeSetVersions[name]++;
        writeSet[name] = value;
    }

    this.getInputOutput = function () {
        return {
            input: readSetVersions,
            output: writeSet
        }
    }

    this.getInternalValues = function(currentPulse, updatePreviousVSD){
        if(updatePreviousVSD){
            myCurrentPulse = currentPulse;
            previousVSD = vsd;
        }
        return {
            cset:cset,
            writeSetVersions:writeSetVersions,
            previousVSD:previousVSD,
            vsd:vsd,
            currentPulse:currentPulse
        }
    }

    this.initialiseInternalValue = function(storedValues){
        if(!storedValues) {
            return;
        }

        cset = storedValues.cset;
        writeSetVersions = storedValues.writeSetVersions;
        vsd = storedValues.vsd;
        writeSet = cset;
        myCurrentPulse = storedValues.currentPulse;
        previousVSD = storedValues.previousVSD;
    }

    function applyTransaction(t){
        let ret = true;

        /*for(let k in t.output){
            if(!t.input.hasOwnProperty(k)){
                ret = "Failed to apply in input.hasOwnProperty for "+ k;
                return ret;
            }
        }*/

        for(let k in t.input){
            let transactionVersion = t.input[k];
            if( transactionVersion == undefined){
                transactionVersion = 0;
            }
            let currentVersion = self.getVersion(k);
            if(currentVersion == undefined || currentVersion == null){
                currentVersion = 0;
            }
            if(transactionVersion != currentVersion){
                //console.log(k, transactionVersion , currentVersion);
                ret = "Failed to apply in transactionVersion != currentVersion (" + transactionVersion + "!="+ currentVersion + ")";
                return ret;
            }
        }

        for(var k in t.output){
            self.writeKey(k, t.output[k]);
        }

		/*var arr = process.hrtime();
		var current_second = arr[0];
		var diff = current_second-t.second;
        */
		return ret;
    }

    this.computePTBlock = function(nextBlockSet){   //make a transactions block from nextBlockSet by removing invalid transactions from the key versions point of view
        var validBlock = [];
        var orderedByTime = cutil.orderTransactions(nextBlockSet);
        var i = 0;

        while(i < orderedByTime.length){
            var t = orderedByTime[i];
            if(applyTransaction(t)){
                validBlock.push(t.digest);
            }
            i++;
        }
        return validBlock;
    }

    this.commit = function(blockSet){
        let i = 0;
        let orderedByTime = cutil.orderCRTransactions(blockSet);

        while(i < orderedByTime.length){
            let t = orderedByTime[i];
            let success = applyTransaction(t);
            if(success !== true){ //paranoid check,  fail to work if a majority is corrupted
                $$.err("Failed to commit a  block. Signal of nasty bug or the stakeholders majority is corrupted!", success);
            }
            i++;
        }
        this.getVSD(true);
    }

    this.getVSD = function(forceCalculation){
        if(forceCalculation){
            var tmp = this.getInternalValues(myCurrentPulse, true);
            vsd = ssutil.hashValues(tmp);
        }
        return vsd;
    }
}

function PDS(worldStateCache, historyStorage){

    var mainStorage = new DataShell(null);
    var self = this;

    var currentPulse = 0;
    var hashOfLatestCommittedBlock = "Genesis Block";

    this.getHandler = function(){ // a way to work with PDS
        var tempStorage = new DataShell(mainStorage);
        return tempStorage;
    }

    this.computeSwarmTransactionDiff = function(swarm, forkedPds){
        var inpOutp     = forkedPds.getInputOutput();
        swarm.input     = inpOutp.input;
        swarm.output    = inpOutp.output;
        return swarm;
    }

    this.computePTBlock = function(nextBlockSet){
        var tempStorage = new DataShell(mainStorage);
        return tempStorage.computePTBlock(nextBlockSet);

    }

    this.commitBlock = function(block, doNotSaveHistory){
        let blockSet = block.blockset;
        currentPulse = block.pulse;
        mainStorage.commit(blockSet);

        hashOfLatestCommittedBlock = block.hash;
        if(!doNotSaveHistory){
            historyStorage.appendBlock( block, false, $$.logError);
        }

        let internalValues = mainStorage.getInternalValues(currentPulse, false);
        internalValues.latestBlockHash = block.hash;
        worldStateCache.updateState(internalValues, $$.logError);
    }

    this.getVSD = function (){
        return mainStorage.getVSD(false);
    }

    this.initialise = function(reportResultCallback){
        let gotLatestBlock_done = false;
        let gotState_done = false;
        let lbn = 0;
        let state = 0;
        var cp = 0;

        function loadNextBlock(){
            if(cp > lbn){
                if(lbn != 0){
                    currentPulse = cp;
                }
                reportResultCallback(null,lbn);
            } else {
                historyStorage.loadSpecificBlock(cp, function(err, block){
                    if(block){
                        self.commitBlock(block, true);
                        cp = block.pulse;
                    }
                    cp++;
                    loadNextBlock();
                })
            }
        }

        function tryToBoot(){
            if(gotState_done &&  gotLatestBlock_done){
                if(state && state.pulse){
                    cp = state.pulse;
                }
                console.log("Reloading from cache at pulse ", cp, "and rebuilding state until pulse", lbn);
                if(state.pulse){
                    mainStorage.initialiseInternalValue(state);
                }
                loadNextBlock();
            }
        }

        function gotLatestBlock(err, val){
            gotLatestBlock_done = true;
            if(!err){
                lbn = val;
            }
            tryToBoot();
        }
        function gotState(err, val){
            gotState_done = true;

            if(!err){
                state = val;
            }
            if(state.latestBlockHash){
                hashOfLatestCommittedBlock = state.latestBlockHash;
            }
            tryToBoot();
        }

        worldStateCache.getState(gotState);
        historyStorage.getLatestBlockNumber(gotLatestBlock);
    }

    this.getCurrentPulse = function(){
        return currentPulse;
    }

    this.setCurrentPulse = function(cp){
        currentPulse = cp;
    }

    this.getPreviousHash = function(){
        return hashOfLatestCommittedBlock;
    }

}


exports.newPDS = function(worldStateCache, historyStorage){
    return new PDS(worldStateCache, historyStorage);
}